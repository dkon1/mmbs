

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3.4. Numeric solutions of ODEs &#8212; Mathematical Methods for Biology</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-dropdown.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/sphinx-book-theme.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="4. Graphical analysis of ordinary differential equations" href="graph_ode_intro.html" />
    <link rel="prev" title="3.1. Ordinary differential equations" href="ode_1var_math.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
  
  <img src="_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Mathematical Methods for Biology</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Introduction
  </a>
 </li>
</ul>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="discrete_1var_intro.html">
   1. Models with one variable in discrete time
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="discrete_nonlinear_intro.html">
   2. Nonlinear discrete-time dynamic models
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="reference internal" href="ode_1var_intro.html">
   3. Models with one variable in continuous time
  </a>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="ode_1var_math.html">
     3.1. Ordinary differential equations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="ode_1var_math.html#analytic-solutions-of-linear-odes">
     3.2. Analytic solutions of linear ODEs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="ode_1var_math.html#membrane-as-electric-circuit">
     3.3. Membrane as electric circuit
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     3.4. Numeric solutions of ODEs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="#implementation-in-python">
     3.5. Implementation in Python
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="graph_ode_intro.html">
   4. Graphical analysis of ordinary differential equations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="discrete_higher_intro.html">
   5. Discrete models of higher order
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linear_pp_intro.html">
   6. Linear ODEs with two variables
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="forces_pot_intro.html">
   7. Forces and potentials in biological modeling
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linearization_pplane.html">
   8. Linearization of ODEs
  </a>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/ode_1var_python.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/executablebooks/jupyter-book/master?urlpath=tree/ode_1var_python.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <a class="colab-button" href="https://colab.research.google.com/github/executablebooks/jupyter-book/blob/master/ode_1var_python.ipynb"><button type="button" class="btn btn-secondary topbarbtn"
                title="Launch Colab" data-toggle="tooltip" data-placement="left"><img class="colab-button-logo"
                    src="_static/images/logo_colab.png"
                    alt="Interact on Colab">Colab</button></a>
        
        
    </div>
</div>

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#forward-euler-method">
   3.4.1. Forward Euler method
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#error-in-numeric-solutions">
   3.4.2. Error in numeric solutions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#backward-euler-method">
   3.4.3. Backward Euler method
  </a>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="numeric-solutions-of-odes">
<h1><span class="section-number">3.4. </span>Numeric solutions of ODEs<a class="headerlink" href="#numeric-solutions-of-odes" title="Permalink to this headline">¶</a></h1>
<p>Analytic solutions are very useful for a modeler because they allow prediction of the variable of interest at any time in the future. However, for many differential equations they are not easy to find, and for many others they simply cannot be written down in a symbolic form. Instead, one can use a numeric approach, which does not require an
exact formula for the solution. The idea is to start at a given initial value (e.g. <span class="math notranslate nohighlight">\(x(0)\)</span>) and use the derivative from the ODE (e.g. <span class="math notranslate nohighlight">\(dx/dt\)</span>) as the rate of change of the solution (e.g. <span class="math notranslate nohighlight">\(x(t)\)</span>) to calculate the
change or increment for the solution over a time step. Essentially, this means replacing the continuous change of the derivative with a discrete time step, thus converting the differential equation into a difference equation and then solving it. The solution of the difference equation is not the same as the solution of the ODE, so <em>numeric solutions</em> of ODEs are always approximate. I will use the notation <span class="math notranslate nohighlight">\(\hat x(t)\)</span> to denote the numeric solution to distinguish it from the exact solution <span class="math notranslate nohighlight">\(x(t)\)</span>. The fundamental difference between them is that <span class="math notranslate nohighlight">\(\hat x(t)\)</span> is not a formula that can be evaluated at any point in time, but instead is a sequence of numbers calculated every time step, which hopefully are close to the exact solution <span class="math notranslate nohighlight">\(x(t)\)</span>.</p>
<div class="section" id="forward-euler-method">
<h2><span class="section-number">3.4.1. </span>Forward Euler method<a class="headerlink" href="#forward-euler-method" title="Permalink to this headline">¶</a></h2>
<p>Let us introduce all the players: first, we need to pick the time step <span class="math notranslate nohighlight">\(\Delta t\)</span>, which is the length of time between successive values of <span class="math notranslate nohighlight">\(\hat x\)</span>. In the difference equation notation one can use <span class="math notranslate nohighlight">\(\hat x_i\)</span> to mean <span class="math notranslate nohighlight">\(\hat x(i\Delta t)\)</span>, the value of the numeric solution after <span class="math notranslate nohighlight">\(i\)</span> time steps. Then we need to calculate the derivative, or the rate of change at a particular point in time. For any first-order ODE of the form</p>
<div class="math notranslate nohighlight">
\[
\frac{d x} {dt} = \dot x = f(x,t)
\]</div>
<p>the rate of change depends (potentially) on the values of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(t\)</span>. This rate of change based on the numeric solution after <span class="math notranslate nohighlight">\(i\)</span> time steps is <span class="math notranslate nohighlight">\(f(\hat x(i\Delta t), i\Delta t) = f(\hat x_i, t_i)\)</span>. Finally, to calculate the change of the dependent variable we need to multiply the rate of change by the time step. This should make sense in a practical context: if you drive for two hours (time step) at 60 miles per hour (rate of change), the total distance (increment) is <span class="math notranslate nohighlight">\(2*60=120\)</span> miles. By the same token, we can write down how to calculate the next value of the numeric solution <span class="math notranslate nohighlight">\(y_{i+1}\)</span> based on the previous one:</p>
<div class="math notranslate nohighlight">
\[
\hat x_{i+1} = \hat x_i + \Delta t f(\hat x_i, t_i) 
 \label{eq:ch15_FE}
\]</div>
<p>This method of computing a numeric solution of an ODE is called the <em>Forward Euler method</em>, after the famous mathematician who first came up with it. It is called a forward method because it uses the value of the dependent variable and its derivative at time step <span class="math notranslate nohighlight">\(i\)</span> to predict the value at the next time step <span class="math notranslate nohighlight">\(i+1\)</span>. The method is <em>iterative</em>, so it needs to be repeated in order to calculate a set of values of the approximate solution <span class="math notranslate nohighlight">\(y(t)\)</span>. Here are a couple of simple examples of computing numeric solution using FE:</p>
<p><strong>Example.</strong> Let us numerically solve the ODE <span class="math notranslate nohighlight">\(\dot x = -0.1\)</span> using the Forward Euler method. This means the defining function in the formulation of FE above is <span class="math notranslate nohighlight">\(f(x,t)=-0.1\)</span>. We can calculate the numeric solution for a couple of steps and compare the values with the exact solution, since we now know that it is <span class="math notranslate nohighlight">\(x(t) = x_0 -0.1t\)</span>. Let us pick the time step <span class="math notranslate nohighlight">\(\Delta t = 0.2\)</span> and begin with the initial value <span class="math notranslate nohighlight">\(x(0)=1\)</span>. Here are the first three steps using the FE method:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
\hat x(0.2) &amp;=&amp; \hat x(0) + \Delta t f(\hat x(0)) = 1 + 0.2 \times (-0.1) &amp;=&amp; 0.98 \\
\hat x(0.4) &amp;=&amp; \hat x(0.2) + \Delta t f(\hat x0.2)) = 0.98+ 0.2 \times (-0.1) &amp;=&amp; 0.96 \\
\hat x(0.6) &amp;=&amp; \hat x(0.4) + \Delta t f(\hat x(0.4)) = 0.96+ 0.2\times (-0.1) &amp;=&amp;0.94
\end{align}
\end{split}\]</div>
<p>Since the rate of change in this ODE is constant, the solution declines by the same amount every time step. In this case, the numeric solution is actually exact and perfectly matches the analytic solution.</p>
<p><strong>Example.</strong> Let us numerically solve the ODE <span class="math notranslate nohighlight">\(\dot x = -0.1x\)</span> using the Forward Euler method. This means the defining function in the formulation of FE above is <span class="math notranslate nohighlight">\(f(x,t)=-0.1x\)</span>. We can calculate the numeric solution for a couple of steps and compare the values with the exact solution, since we now know that it is <span class="math notranslate nohighlight">\(x(t) = x_0 e^{-0.1t}\)</span>. Let us pick the time step <span class="math notranslate nohighlight">\(\Delta t = 0.2\)</span> and begin with the initial value <span class="math notranslate nohighlight">\(x(0)=100\)</span>. Here are the first three steps using the FE method:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
\hat x(0.2) &amp;=&amp; \hat x(0) + \Delta t f(\hat x(0)) = 100 + 0.2\times (-0.1*100) &amp;=&amp; 98 \\
\hat x(0.4) &amp;=&amp; \hat x(0.2) + \Delta t f(\hat x(0.2)) = 98+ 0.2\times (-0.1*98) &amp;=&amp; 96.04 \\
\hat x(0.6) &amp;=&amp; \hat x(0.4) + \Delta t f(\hat x(0.4)) = 96.04+ 0.2\times (-0.1*96.04) &amp;=&amp; \approx 94.12
\end{align}
\end{split}\]</div>
<p>In this case, the derivative is not constant and the numeric solution is not exact. The error in the numeric solution grows with time, which may be problematic. We will further investigate how to implement the computation of numeric solutions using R in the next section.</p>
</div>
<div class="section" id="error-in-numeric-solutions">
<h2><span class="section-number">3.4.2. </span>Error in numeric solutions<a class="headerlink" href="#error-in-numeric-solutions" title="Permalink to this headline">¶</a></h2>
<p>One of the main concerns of numerical analysis is to minimize the difference between the exact solution and the numeric solution, which is known as the <em>error</em>. There are at least two distinct sources of error in numeric solutions: a) <em>roundoff error</em> and b) <em>truncation error</em>. Roundoff error is caused by computers representing real numbers by a finite string of bits on a computer using what is known as a <em>floating point</em> representation. In many programming languages variables storing real numbers can be single or double precision, which typically
support 24 and 53 significant binary digits, respectively. Any arithmetic operation involving floating point numbers is only approximate, with an error that depends on the way the numbers are stored in the memory. Truncation error is caused by approximations inherent in numeric algorithms. The most common class of numeric approximations for ODEs is known as <em>finite difference</em> methods, and Forward Euler is a very simple representative of that class. As the name
suggests, these methods use difference equations to approximate a differential equation. There is inevitably a truncation error in such methods because they use a more or less clever scheme to approximate the instantaneous rate of change in an ODE, which can be thought as a truncation of the Taylor series after certain term.</p>
<p>A modeler has different controls over the roundoff error and truncation error. The first can be minimized by using more memory to store the numbers, e.g. by using double precision format for the variables. Further, there are techniques for minimizing the so-called loss of significance that occurs in certain arithmetic operations, like
subtraction of two similar numbers. We will leave these considerations to numerical analysts [&#64;press_numerical_2007]; for the most part, roundoff error is not a significant issue on modern computers. Truncation error, however, is much more within our control, because it depends on the choice of the numerical algorithm. One can decrease the error in the case of finite difference methods by choosing smaller time steps, or by choosing an algorithm with a higher <em>order of accuracy</em>.</p>
<p>Returning specifically to the Forward Euler method, it is called a <em>first-order method</em> because the total error of the solution (after some number of time steps) depends linearly on the time step <span class="math notranslate nohighlight">\(\Delta t\)</span>. One can show this by using the Taylor expansion of the solution <span class="math notranslate nohighlight">\(\hat x(t)\)</span> to derive the forward Euler method, with <span class="math notranslate nohighlight">\(\tau(\Delta t)\)</span> representing the
truncation error after one time step:</p>
<div class="math notranslate nohighlight">
\[
\hat x(t+\Delta t) = \hat x(t) +  \Delta t \frac{d\hat x(t)}{dt} + \tau(\Delta t)
\]</div>
<p>As you might have learned in calculus, the error remaining after the linear term in the Taylor series is proportional to the the square of the small deviation <span class="math notranslate nohighlight">\(\Delta t\)</span>. This only describes the error after 1 time step, but since the errors accumulate every time step, the total error after <span class="math notranslate nohighlight">\(n\)</span> time steps accumulates <span class="math notranslate nohighlight">\(n \tau(\Delta t)\)</span>. As we saw in
the implementation above, for a given length of time, <span class="math notranslate nohighlight">\(n\)</span> is inversely proportional to <span class="math notranslate nohighlight">\(\Delta t\)</span>. Therefore, the total error is proportional to the <span class="math notranslate nohighlight">\(\Delta t\)</span> and so FE is a first-order method.</p>
<p>The exercise above shows that new errors in FE method accumulate in proportion with the time step. The next question is, what happens to these errors over time? Do they grow or dissipate with more iterations? This is known as the stability of a numerical method, and unlike the above question about the order of accuracy, the answer depends on the particular ODE that one needs to solve. Below I show an example of error analysis for a linear ODE:</p>
<div class="topic">
<p class="topic-title">Error in the FE scheme</p>
<p>To numerically solve the equation <span class="math notranslate nohighlight">\(\dot x = ax\)</span>, we substitute the function <span class="math notranslate nohighlight">\(ax\)</span> for the function <span class="math notranslate nohighlight">\(f(x,t)\)</span>, and obtain the FE approximation for this particular ODE:</p>
<div class="math notranslate nohighlight">
\[
\hat x_{i+1} = \hat x_i + \Delta t a \hat x_i = (1+a\Delta t) \hat x_i
\]</div>
<p>The big question is what happens to the truncation error: does it grow or decay? To investigate this question, let us denote the error at time <span class="math notranslate nohighlight">\(t_i\)</span> , that is the difference between the true solution <span class="math notranslate nohighlight">\(x(t_i)\)</span> and the approximate
solution <span class="math notranslate nohighlight">\(\hat x(t_i)\)</span>, by <span class="math notranslate nohighlight">\(\epsilon_i\)</span>. It follows that <span class="math notranslate nohighlight">\(\hat x_i = x_i + \epsilon_i\)</span>. Then we can wrote the following difference equations involving the error:</p>
<div class="math notranslate nohighlight">
\[
\hat x_{i+1} = x_{i+1} + \epsilon_{i+1} = (x_i + \epsilon_i) (1+a\Delta t)  = x_i (1+a\Delta t) + \epsilon_i(1+a\Delta t)
\]</div>
<p>Let us set aside the terms in the equation that involve <span class="math notranslate nohighlight">\(x\)</span> (since it is just the equation for forward Euler). The remaining difference equation for <span class="math notranslate nohighlight">\(\epsilon\)</span> describes the change in the error:</p>
<div class="math notranslate nohighlight">
\[
\epsilon_{i+1} = \epsilon_i(1+a\Delta t)
\]</div>
<p>This states that the error in this numeric solution is repeatedly multiplied by the constant <span class="math notranslate nohighlight">\((1+a\Delta t)\)</span>. As we saw in section [sec:math14], this linear difference equation has an exponential solution <span class="math notranslate nohighlight">\(\epsilon_n = (1+a\Delta t)^n \epsilon_0\)</span>, which decays to 0 if <span class="math notranslate nohighlight">\(|1+a\Delta t| &lt; 1\)</span> or grows without bound if <span class="math notranslate nohighlight">\(|1+a\Delta t| &gt; 1\)</span>. The
first inequality is called the stability condition for the FE scheme, since it guarantees that the old errors decay over time. Since <span class="math notranslate nohighlight">\(\Delta t &gt;0\)</span>, the only way that the left hand side can be less than 1 is if <span class="math notranslate nohighlight">\(a&lt;0\)</span>. Therefore, the condition for stability of the FE method for a linear ODE:
$<span class="math notranslate nohighlight">\(
|1 + a\Delta t| &lt; 1 \Rightarrow \Delta t &lt; -2/a
\)</span>$</p>
<p>Thus, if <span class="math notranslate nohighlight">\(a&gt;0\)</span>, the errors will eventually overwhelm the solution. If <span class="math notranslate nohighlight">\(a&lt;0\)</span>, if the time step is small enough (less than <span class="math notranslate nohighlight">\(-2/a\)</span>) then FE is stable.</p>
</div>
<p>Generally speaking, however, Forward Euler is about the worst method to use for practical numeric solutions of ODEs, due to its low accuracy and to its lack of stability under certain conditions.</p>
</div>
<div class="section" id="backward-euler-method">
<h2><span class="section-number">3.4.3. </span>Backward Euler method<a class="headerlink" href="#backward-euler-method" title="Permalink to this headline">¶</a></h2>
<p>More sophisticated numeric methods generally offer better stability than Forward Euler. For instance, there is a class of methods called <em>implicit</em> schemes which rely on evaluating the value of the derivative of <span class="math notranslate nohighlight">\(x\)</span> at a future time point. This may seem impossible, since we do not yet have the value of the dependent variable <span class="math notranslate nohighlight">\(x\)</span> in the future, only in the present. In fact, we can set up an algebraic relationship between the present value of <span class="math notranslate nohighlight">\(x\)</span>, the future value of <span class="math notranslate nohighlight">\(x\)</span>, and the derivative of <span class="math notranslate nohighlight">\(x\)</span> in the future. Then, depending on the form of the defining function <span class="math notranslate nohighlight">\(f(x)\)</span>, we may solve this relationship for the value of <span class="math notranslate nohighlight">\(x\)</span> at the future time.</p>
<p>To make the idea of implicit methods concrete, we will introduce a simple method called the Backward Euler. As suggested by the name, this method is essentially similar to the Forward Euler, but with the future value of <span class="math notranslate nohighlight">\(x_{i+1}\)</span> substituted in the defining function instead of the current value:</p>
<div class="math notranslate nohighlight">
\[
\hat x_{i+1} = \hat x_i + \Delta t \frac {d\hat x_{i+1}}{dt} = \hat x_i + \Delta t f(\hat x_{i+1})
\]</div>
<p>How can we calculate the value of <span class="math notranslate nohighlight">\(f(\hat x_{i+1})\)</span> if you don’t know <span class="math notranslate nohighlight">\(\hat x_{i+1}\)</span>? Depending on the form of <span class="math notranslate nohighlight">\(f(x)\)</span>, it may be possible to algebraically solve for <span class="math notranslate nohighlight">\(\hat x_{i+1}\)</span>. If we can solve the implicit expression for <span class="math notranslate nohighlight">\(y_{i+1}\)</span>, we can program a numeric scheme that will compute the value <span class="math notranslate nohighlight">\(\hat x_{i+1}\)</span> directly from <span class="math notranslate nohighlight">\(\hat x_i\)</span>. In other situations, the implicit expression may be impossible to solve algebraically. The practitioner may then use a method for solving such an expression numerically, using a numerical root-finding algorithm such as Newton’s method that we will see later in this course.</p>
<div class="topic">
<p class="topic-title">Error in the BE scheme</p>
<p>Here is the implementation of the Backward Euler for the linear ODE <span class="math notranslate nohighlight">\(\dot x = a x\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\hat x_{i+1} = \hat x_i + \Delta t a \hat x_{i+1}
\]</div>
<p>For this particular ODE, the implicit equation can be solved for the future value <span class="math notranslate nohighlight">\(\hat x_{i+1}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
(1- a\Delta t) \hat x_{i+1} = \hat x_i \Longrightarrow \hat x_{i+1} = \frac{1}{1- a\Delta t} \hat x_i
\]</div>
<p>Now we use the same stability analysis as we did for Forward Euler: assume the numerical solution <span class="math notranslate nohighlight">\(\hat x_i\)</span> has total error <span class="math notranslate nohighlight">\(\epsilon_i\)</span>, and substitute <span class="math notranslate nohighlight">\(\hat x_i = x_i + \epsilon_i\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\hat x_{i+1} = x_{i+1} + \epsilon_{i+1} = \frac{1}{1- a\Delta t}  (x_i  + \epsilon_i) =  \frac{1}{1- a\Delta t} x_i + \epsilon_i \frac{1}{1- a\Delta t}
\]</div>
<p>Again, let us comapare the numeric solution <span class="math notranslate nohighlight">\(\hat x\)</span> with the excact solution <span class="math notranslate nohighlight">\(x\)</span> and investigate the behavior of the error, which is given by the difference equation:</p>
<div class="math notranslate nohighlight">
\[
\epsilon_{i+1} = \frac{1}{1- a\Delta t}   \epsilon_i
\]</div>
<p>The error decays with time if the multiplicative constant <span class="math notranslate nohighlight">\(1/(1- a\Delta t)\)</span> is less than 1 in absolute value, which can be written as <span class="math notranslate nohighlight">\(|1- a\Delta t| &gt;1 \)</span>. We need to consider two cases: positive <span class="math notranslate nohighlight">\(a\)</span> and negative <span class="math notranslate nohighlight">\(a\)</span>:</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(a &gt; 0\)</span>, then <span class="math notranslate nohighlight">\(|1- a\Delta t|\)</span> is greater than 1 provided that <span class="math notranslate nohighlight">\(\Delta t &gt; 1/|a|\)</span>, so the Backward Euler scheme for the exponential growth ODE is stable when <span class="math notranslate nohighlight">\(\Delta t\)</span> is greater than a certain threshold. This appears counterintuitive, so it is worth investigating in the lab.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(a &lt; 0\)</span>, then <span class="math notranslate nohighlight">\(|1- a\Delta t|\)</span> is greater than 1 for any value of <span class="math notranslate nohighlight">\(\Delta t\)</span>, so it is <em>unconditionally stable</em>. This is also worth investigating with numeric experimentation.</p></li>
</ul>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Necessary imports</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> <span class="c1">#package for work with arrays and matrices</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1">#package with plotting capabilities</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="implementation-in-python">
<h1><span class="section-number">3.5. </span>Implementation in Python<a class="headerlink" href="#implementation-in-python" title="Permalink to this headline">¶</a></h1>
<div class="section" id="forward-euler">
<h2><span class="section-number">3.5.1. </span>Forward Euler<a class="headerlink" href="#forward-euler" title="Permalink to this headline">¶</a></h2>
<p>We defined the Forward Euler method in the section above, and now we will implement is as a computational algorithm. Like any algorithm, one needs to be clear about its inputs and outputs. In this case, the inputs are the defining function <span class="math notranslate nohighlight">\(f(x,t)\)</span>, the initial value, the time step, and the total time. The output is the solution vector <span class="math notranslate nohighlight">\(y\)</span>, which contains a sequence of values that approximate the solution of the ODE, along with the vector of time values spaced by the time step. Notice that it is very similar to the script for numeric solution of a difference equation we saw in chapter 1 with the major difference being the presence of a time step, whereas in difference equations the time step is aways 1. There is one more important point for the implementation: usually one needs to solve the ODE for a particular length of time <span class="math notranslate nohighlight">\(T\)</span> with a specified time step <span class="math notranslate nohighlight">\(\Delta t\)</span> . This dictates that the required number of iterations be <span class="math notranslate nohighlight">\(T/\Delta t\)</span>; in other words, for a given time period the number of time steps is inversely proportional to the time step.</p>
<div class="tip admonition">
<p class="admonition-title">Outline (pseudocode) for the Forward Euler algorithm</p>
<ul class="simple">
<li><p>Specify the defining function for the ODE <span class="math notranslate nohighlight">\(f(x)\)</span></p></li>
<li><p>Set the time step <span class="math notranslate nohighlight">\(dt\)</span> and the total length of time <span class="math notranslate nohighlight">\(T\)</span></p></li>
<li><p>Calculate the number of steps <span class="math notranslate nohighlight">\(n \gets T/dt\)</span></p></li>
<li><p>Initialize the time array <span class="math notranslate nohighlight">\(t\)</span> with <span class="math notranslate nohighlight">\(n + 1\)</span> elements</p></li>
<li><p>Initialize the solution array <span class="math notranslate nohighlight">\(x\)</span> with <span class="math notranslate nohighlight">\(n + 1\)</span> elements and initial value <span class="math notranslate nohighlight">\(x_0\)</span></p></li>
<li><p>Use a for loop to compute the next <span class="math notranslate nohighlight">\(x(i+1)\)</span> based on the current <span class="math notranslate nohighlight">\(x(i)\)</span> for <span class="math notranslate nohighlight">\(n\)</span> steps</p></li>
</ul>
</div>
<p>Below we implement the Forward Euler method to solve the linear ODE</p>
<div class="math notranslate nohighlight">
\[
dx/dt = r*x
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Implementation of Forward Euler method to solve dx/dt = r*x</span>

<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1">#set the time step</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">50</span> <span class="c1">#set the time duration</span>
<span class="n">Niter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span> <span class="c1">#determine the number of iterations</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Niter</span><span class="p">)</span> <span class="c1">#preallocate the solution array</span>
<span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span> <span class="c1">#set the initial value</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">dt</span><span class="p">)</span> <span class="c1">#preallocate the time array</span>
<span class="n">r</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1">#set the growth rate</span>

<span class="c1">#Do the Euler!</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Niter</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">r</span><span class="o">*</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1">#this is the FE step</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>  
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;solution&#39;</span><span class="p">)</span> 
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Forward Euler Example&#39;</span><span class="p">)</span> 
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ode_1var_python_3_0.png" src="_images/ode_1var_python_3_0.png" />
</div>
</div>
<p>The plot should look like an exponential curve, which seems reasonable, but how accurate is it? Remember from the reading that we can define the error of FE at each point, <span class="math notranslate nohighlight">\(t\)</span>, as <span class="math notranslate nohighlight">\(|x(t)- \hat x(t)|=\epsilon(t)\)</span>. Also, we can define the algorithm as stable if the error at some point, <span class="math notranslate nohighlight">\(t\)</span>, does not grow so that <span class="math notranslate nohighlight">\(\left|x(t+1)- \hat x(t+1)\right| \leq \epsilon(t)\)</span>, where <span class="math notranslate nohighlight">\(x(t)\)</span> is the exact solution.</p>
</div>
<div class="section" id="backward-euler">
<h2><span class="section-number">3.5.2. </span>Backward Euler<a class="headerlink" href="#backward-euler" title="Permalink to this headline">¶</a></h2>
<p>Now we’ll turn to the second method introduced above, Backward Euler (BE). This time, instead of evaluating <span class="math notranslate nohighlight">\(f(x,t)\)</span> at the present time for finding the future point, we use the future point itself! In order to do this, we set up an
algebraic relationship between the present value, the future value, and the derivative of the future value such that</p>
<div class="math notranslate nohighlight">
\[
\hat x(t+\Delta t) = \hat x(t) + dt*f(\hat x(t+\Delta t)) + \epsilon(t)
\]</div>
<p>Then, we must solve for <span class="math notranslate nohighlight">\(\hat x(t+\Delta t)\)</span>. Sometimes this will be impossible to do algebraically, but it may be possible to solve the equation numerically. Once we solve for <span class="math notranslate nohighlight">\(x(t+1)\)</span>, the steps for implementing the algorithm are
similar to the ones for Forward Euler:</p>
<div class="tip admonition">
<p class="admonition-title">Outline (pseudocode) for the Backward Euler algorithm</p>
<ul class="simple">
<li><p>Specify the defining function for the ODE <span class="math notranslate nohighlight">\(f(x)\)</span></p></li>
<li><p>Set the time step <span class="math notranslate nohighlight">\(dt\)</span> and the total length of time <span class="math notranslate nohighlight">\(T\)</span></p></li>
<li><p>Calculate the number of steps <span class="math notranslate nohighlight">\(n \gets T/dt\)</span></p></li>
<li><p>Initialize the time array <span class="math notranslate nohighlight">\(t\)</span> with <span class="math notranslate nohighlight">\(n + 1\)</span> elements</p></li>
<li><p>Initialize the solution array <span class="math notranslate nohighlight">\(x\)</span> with <span class="math notranslate nohighlight">\(n + 1\)</span> elements and initial value <span class="math notranslate nohighlight">\(x_0\)</span></p></li>
<li><p>Use a for loop to compute the next <span class="math notranslate nohighlight">\(x(i+1)\)</span> based on the current <span class="math notranslate nohighlight">\(x(i)\)</span> for <span class="math notranslate nohighlight">\(n\)</span> steps</p></li>
</ul>
</div>
<p>Below is an</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#Implementation of Backward Euler method to solve dx/dt = r*x</span>

<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1">#set the time step</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">50</span> <span class="c1">#set the time duration</span>
<span class="n">Niter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span> <span class="c1">#determine the number of iterations</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Niter</span><span class="p">)</span> <span class="c1">#preallocate the solution array</span>
<span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2000</span> <span class="c1">#set the initial value</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Niter</span><span class="p">)</span> <span class="c1">#preallocate the time array</span>
<span class="n">r</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1">#set the growth rate</span>

<span class="c1">#Do the Euler!</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Niter</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="c1">#this is the BE step</span>
    <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span> <span class="c1">#add the current time to the time vector</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>  
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;solution&#39;</span><span class="p">)</span> 
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Backward Euler Example&#39;</span><span class="p">)</span> 
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> 
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/ode_1var_python_6_0.png" src="_images/ode_1var_python_6_0.png" />
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="ode_1var_math.html" title="previous page"><span class="section-number">3.1. </span>Ordinary differential equations</a>
    <a class='right-next' id="next-link" href="graph_ode_intro.html" title="next page"><span class="section-number">4. </span>Graphical analysis of ordinary differential equations</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Dmitry Kondrashov<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="_static/js/index.js"></script>
    
  </body>
</html>