
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fourier series: decomposition by frequency &#8212; Mathematical Methods for Biology</title>
    
  <link href="_static/css/theme.css" rel="stylesheet" />
  <link href="_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.e8f53015daec13862f6db5e763c41738.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Mathematical Methods for Biology</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Introduction
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  One variable models
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="discrete_1var_intro.html">
   Models with one variable in discrete time
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="discrete_1var_math.html">
     1. Building dynamic models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="discrete_1var_python.html">
     3. Plotting in Python
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="discrete_nonlinear_intro.html">
   Nonlinear discrete-time dynamic models
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="discrete_nonlinear_math.html">
     10. Logistic population model
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="discrete_nonlinear_python.html">
     13. Graphical analysis of difference equations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="ode_1var_intro.html">
   21. Models with one variable in continuous time
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="ode_1var_math.html">
     21.1. Ordinary differential equations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="ode_1var_python.html">
     21.4. Numeric solutions of ODEs
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="graph_ode_intro.html">
   Graphical analysis of ordinary differential equations
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="graph_ode_math.html">
     18. Building nonlinear ODEs
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Multivariable models
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="discrete_higher_intro.html">
   Discrete models of higher order
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="discrete_higher_math.html">
     5. higher order difference equations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="discrete_higher_python.html">
     8. Numeric solutions of higher order difference equations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="linear_pp_intro.html">
   22. Linear ODEs with two variables
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="linear_pp_math.html">
     22.1. Flow in the phase plane
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="linear_pp_python.html">
     22.6. Phase portraits in Python
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="forces_pot_intro.html">
   Forces and potentials in biological modeling
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="forces_pot_math.html">
     15. Forces and simple springs
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linearization_pplane.html">
   23. Linearization of ODEs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="nonlinear_oscillations.html">
   24. Nonlinear oscillations in biology
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/chapter8.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   Introduction
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#modeling-periodicity-and-its-applications">
   Modeling: periodicity and its applications
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#amplitude-period-and-frequency">
     amplitude, period, and frequency
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#brain-waves-in-eeg">
     brain waves in EEG
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#analytical-sines-and-cosines-as-a-basis-set-for-periodic-functions">
   Analytical: sines and cosines as a basis set for periodic functions
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#complex-fourier-series">
     complex Fourier series
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sampling-theorem-and-aliasing">
     Sampling theorem and aliasing
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#discrete-fourier-transform">
     Discrete Fourier Transform
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#computational-fast-fourier-transform">
   Computational: Fast Fourier Transform
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#splitting-the-data-into-even-and-odd-inputs">
     splitting the data into even and odd inputs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#recursive-splitting-and-reassembly">
     recursive splitting and reassembly
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="fourier-series-decomposition-by-frequency">
<h1>Fourier series: decomposition by frequency<a class="headerlink" href="#fourier-series-decomposition-by-frequency" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In this part of the course we will turn to areas of mathematics and
computation that have applications to data analysis. Depending on the
source of the data and the goals of the analyst, one can extract
different kinds of information from a data set. There is usually one
common goal of data analysis: simplification. It stand to reason, since
if the data set were simple, quantitative analysis would be superfluous.
Fortunately, there is no shortage of complex, messy data in biology.</p>
<p>At least two kinds of data analysis can be distinguished: extraction of
simplified information, and fitting a model to the data. In chapters 13
and 14 we will present the method of Fourier analysis, which extracts
information about frequency from a data set, while in chapters 15 and 16
we discuss optimization, which, among many other uses, enables the
fitting of models to data sets.</p>
<p>In the modeling section we motivate the notion of frequency analysis
with the example of electro-encephalogram recordings of electrical
activity of the central nervous system. The analytic section develops
the mathematical notion of function spaces, and the basis of sine and
cosine functions. This is used for Fourier decomposition, or description
of an arbitrary periodic function as a sum of sines and cosines. In the
computational section, we describe the computation of Fourier
decomposition using an efficient algorithm called the Fast Fourier
Transform, which is a seminal development in the history of computation.</p>
</div>
<div class="section" id="modeling-periodicity-and-its-applications">
<h2>Modeling: periodicity and its applications<a class="headerlink" href="#modeling-periodicity-and-its-applications" title="Permalink to this headline">¶</a></h2>
<div class="section" id="amplitude-period-and-frequency">
<h3>amplitude, period, and frequency<a class="headerlink" href="#amplitude-period-and-frequency" title="Permalink to this headline">¶</a></h3>
<p>Many biological processes are periodic, that is repetitive, with a
particular pattern that serves biological needs; common examples are
waves of activity in the heart muscle, repeated spikes of voltage across
neural membranes, and daily Circadian rhythms in physiological
regulation. It is highly useful to measure the properties of these
periodic activities, and to describe them using idealized mathematical
functions, specifically sines and cosines.</p>
<p>As a reminder sines and cosines both have period <span class="math notranslate nohighlight">\(2\pi\)</span>, but the sine is
an odd function: <span class="math notranslate nohighlight">\(\sin(x) = -\sin(-x)\)</span>, whereas the cosine is an even
function: <span class="math notranslate nohighlight">\(\cos(x) = \cos(-x)\)</span>. Furthermore, by adding a couple of
parameters, one can produce a sine or cosine wave of any period and any
amplitude. In the following expression, the amplitude of both the sine
and the cosine is <span class="math notranslate nohighlight">\(L\)</span>, and thus the frequency is <span class="math notranslate nohighlight">\(1\L\)</span>, while the
amplitude of the sine is <span class="math notranslate nohighlight">\(A\)</span> and that of the cosine is <span class="math notranslate nohighlight">\(B\)</span>.
$<span class="math notranslate nohighlight">\(A \cos(2\pi x/L); \;  B\sin(2\pi x/L)\)</span>$</p>
</div>
<div class="section" id="brain-waves-in-eeg">
<h3>brain waves in EEG<a class="headerlink" href="#brain-waves-in-eeg" title="Permalink to this headline">¶</a></h3>
<p>Of course, not all periodic functions are sines and cosines, but sines
and cosines can be used to describe the types of frequencies present in
a periodic signal. Consider the following electroencephalograph (EEG)
data collected from electrodes on the scalp of a human:</p>
<p><img alt="EEG dataexample[]{data-label=&quot;fig:EEG_recording&quot;}" src="_images/EEG_recording.png" /></p>
<p>By inspection, it appears as if there are some periodic processes
producing these data, but these are not neat periodic sine or cosine
waves. Instead, we have many different overlapping signals, produced by
huge numbers of electrical pulses in the brain, each with different
frequency. In order to analyze this signal, we need to <em>decompose</em> it
into contributions of different frequencies. Signals of different
frequencies,called brain waves in neuroscience, serve distinct purposes:
for instance, different stages of sleep can be characterized by the
frequencies of the brain waves. In the following section we will learn
how to describe complex, periodic data sets, such as the one in figure
[fig:EEG_recording], in terms of the contributions, or amplitudes, of
sines and cosines of different frequencies. This way we can quantify the
presence of different types of brain waves in a given EEG recording.</p>
</div>
</div>
<div class="section" id="analytical-sines-and-cosines-as-a-basis-set-for-periodic-functions">
<h2>Analytical: sines and cosines as a basis set for periodic functions<a class="headerlink" href="#analytical-sines-and-cosines-as-a-basis-set-for-periodic-functions" title="Permalink to this headline">¶</a></h2>
<p>We now introduce the idea of a space of functions, instead of vectors,
and describe how to decompose any given function in terms of a basis of
other functions. Joseph Fourier postulated in 1822 that any function can
be described by an infinite sum of sine functions. Some of the details
were incorrect, but he introduced an a revolutionary concept that has
found fundamental applications in a multitude of fields of science, from
acoustics to medical imaging. The fact is that any function on a finite
interval of length <span class="math notranslate nohighlight">\(L\)</span> (or a periodic function with period <span class="math notranslate nohighlight">\(L\)</span>, which is
equivalent) can be represented exactly by an infinite sum of sines and
cosines, plus a constant term:
$<span class="math notranslate nohighlight">\(f(x) = a_0 + \sum_{k=1}^\infty a_k \cos(2\pi k x/L)   + \sum_{i=1}^\infty b_k \sin(2\pi k x/L)\)</span><span class="math notranslate nohighlight">\(
Notice that this is the same concept of decomposition in terms of a
basis set. Any such function can be written as the sum of sines and
cosines, and only the coefficients are different for different
functions. The main difference is that vector spaces (such as
\)</span>\mathbb{R}^3<span class="math notranslate nohighlight">\() have finite basis sets of vectors, while a function
space (e.g. the space of all functions with period \)</span>L$) has an infinite
basis set of functions (e.g. sines and cosines with different
frequencies.) To be specific, let us define these concepts.</p>
<p>A <em>function space</em> is a collection of all functions defined over a given
domain, for example the interval <span class="math notranslate nohighlight">\([-L/2, L/2]\)</span>, that have a finite norm,
to be defined below.</p>
<p>The notion of the norm of a function is similar to the norm, or
magnitude of a vector. The reason for restricting function spaces to
functions with a finite norm, is to ensure that computations of various
quantities of interests are valid and do not blow up. Now let us define
the function norm:</p>
<p>The <em>norm</em> of a function <span class="math notranslate nohighlight">\(f(x)\)</span>, denoted <span class="math notranslate nohighlight">\(||f||\)</span>, is a mapping from the
function space into nonnegative real numbers, which obeys the following
rules:</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(||f|| = 0\)</span> iff <span class="math notranslate nohighlight">\(f(x) = 0\)</span> (the function is zero everywhere)</p></li>
<li><p><span class="math notranslate nohighlight">\(||af|| = a||f||\)</span> for any real number <span class="math notranslate nohighlight">\(a\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(|| f+g || \leq ||f|| + ||g||\)</span> for any functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> in the
function space (triangle inequality)</p></li>
</ol>
<p>The norm that we will utilize in the function spaces is called the <span class="math notranslate nohighlight">\(L^2\)</span>
norm and it is defined as follows:</p>
<p>The <span class="math notranslate nohighlight">\(L^2\)</span> norm of a real-valued function <span class="math notranslate nohighlight">\(f(x)\)</span> over an interval
<span class="math notranslate nohighlight">\([-L/2,L/2]\)</span> is defined as follows:
$<span class="math notranslate nohighlight">\(||f|| =\sqrt{ \int_{-L/2}^{L/2} f(x)^2 dx}\)</span>$</p>
<p>The <span class="math notranslate nohighlight">\(L^2\)</span> norm in function spaces is the square root of the integral of
the square of the function values over the interval of its definition
(which can be extended to the entire real number line, in the limit of
<span class="math notranslate nohighlight">\(L \to \infty\)</span>). This is the equivalent of the Euclidean distance norm
in vector spaces, which if you recall is the square root of the sum of
squares of all the components of the vector. There are many possible
norms of function spaces, but the <span class="math notranslate nohighlight">\(L^2\)</span> norm is mathematically special,
because it is derived from the inner product of the function space:</p>
<p>The <em>inner product</em> between two functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> defined on the
same interval <span class="math notranslate nohighlight">\([-L/2,L/2]\)</span> is:
$<span class="math notranslate nohighlight">\(&lt;f, g&gt;  = \int_{-L/2}^{L/2} f(x)g(x) dx\)</span>$</p>
<p>The function norm can be defined in terms of the inner product:
<span class="math notranslate nohighlight">\(||f(x)|| = \sqrt{&lt;f(x), f(x)&gt;}\)</span>. This defines the machinery for
computing the “size” of a function, measured by its norm, as well as the
“similarity” between two functions, measured by the inner product. If
two functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are very similar, the inner product is close
to the square of the norm of <span class="math notranslate nohighlight">\(f\)</span> (or <span class="math notranslate nohighlight">\(g\)</span>). If <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are very
similar, but flipped by a negative sign, the inner product is close to
negative of the square of the norm of <span class="math notranslate nohighlight">\(f\)</span> (or <span class="math notranslate nohighlight">\(g\)</span>). On the other hand,
if the two functions are dissimilar - loosely speaking, if <span class="math notranslate nohighlight">\(f\)</span> is
positive, <span class="math notranslate nohighlight">\(g\)</span> is sometimes positive, sometimes negative, then the
product of the values of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> is sometimes positive and sometimes
negative, and thus its integral will add to be close to zero. This is
how one can define orthogonality of two functions:</p>
<p>Two functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> in a function space are <em>orthogonal</em> if
<span class="math notranslate nohighlight">\(&lt;f,g&gt; = 0\)</span>.</p>
<p>Now that we can describe the coefficients for the sines are cosines, by
using the inner product of the function we are decomposing, with the
basis functions (sines and cosines) in a manner analogous to the basis
decomposition described for vector spaces in Chapter 8. The coefficients
for the sines and cosines of the Fourier decomposition of a function
<span class="math notranslate nohighlight">\(f(x)\)</span> with period <span class="math notranslate nohighlight">\(L\)</span> are found as follows:
$<span class="math notranslate nohighlight">\(a_k = \frac{ &lt;f(x),\cos(2\pi k x/L) &gt; }{  &lt;\cos(2\pi k x/L) ,\cos(2\pi k x/L) &gt;} =\frac{2}{L} \int _{-\frac{L}{2}} ^{\frac{L}{2}} f(x) \cos(2\pi k x/L) dx\)</span>$</p>
<div class="math notranslate nohighlight">
\[b_k = \frac{ &lt;f(x), \sin(2\pi k x/L)&gt; }{  &lt; \sin(2\pi k x/L), \sin(2\pi k x/L)&gt;} = \frac{2}{L} \int _{-\frac{L}{2}} ^{\frac{L}{2}} f(x) \sin(2\pi k x/L) dx\]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}a_0 = \frac{1}{L} \int _{-\frac{L}{2}} ^{\frac{L}{2}} f(x)dx$$ The
factor of $L/2$ in front of the integrals serves to divide out the norm
of the basis function. Note that the constant term $c_0$ is the mean
value of the function on the interval $(-L/2, L/2)$ - it moves the
function up or down, while the sines and cosines all have the mean value
of zero.\\**Example: Fourier decomposition of a square wave.** Take a common
example of a simple function subject to Fourier decomposition: a square
wave, which is a function which equals one constant value (e.g. -1) for
half of the interval, and another constant (e.g. 1) for the other half
of the interval. Here is how we find the coefficients of the sines and
cosines analytically:\\![Approximations of a square wave with successive contributions of the
Fourier
series.[]{data-label=&quot;fig:square_series&quot;}](images/square_series.png)\\$$a_k = \frac{2}{L} \int _{-\frac{L}{2}} ^{\frac{L}{2}} f(x) \cos(2\pi k x/L) dx = \frac{2}{L} \int _{-\frac{L}{2}} ^0 -\cos(2\pi k x/L) dx + \frac{2}{L} \int _0 ^{\frac{L}{2}}  \cos(2\pi k x/L) dx =\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[= \frac{2}{L} \left[ \frac{L}{2\pi k} \sin(2\pi k x/L) |_{-\frac{L}{2}} ^0   -  \frac{L}{2\pi k}  \sin(2\pi k x/L)|_0^{\frac{L}{2}} \right] = \frac{1}{\pi k} \left[ 0-0 -0+0\right] = 0\]</div>
<div class="math notranslate nohighlight">
\[b_k = \frac{2}{L} \int _{-\frac{L}{2}} ^{\frac{L}{2}} f(x) \sin(2\pi k x/L) dx = \frac{2}{L} \int _{-\frac{L}{2}} ^0 -\sin(2\pi k x/L) dx + \frac{2}{L} \int _0 ^{\frac{L}{2}}  \sin(2\pi k x/L) dx =\]</div>
<div class="math notranslate nohighlight">
\[= \frac{2}{L} \left[ -\frac{L}{2\pi k} \cos(2\pi k x/L) |_{-\frac{L}{2}} ^0   + \frac{L}{2\pi k}  \cos(2\pi k x/L)|_0^{\frac{L}{2}} \right] = \frac{1}{\pi k} \left[ 1 -  \cos(\pi k)  + 1 - \cos(\pi k) \right] = 0 \; or \; \frac{4}{\pi k}\]</div>
<p>The coefficients for the cosines are zeros, but there are nonzero values
for the sines, when <span class="math notranslate nohighlight">\(k\)</span> is odd, and <span class="math notranslate nohighlight">\(\cos(\pi k)  = -1\)</span>. When <span class="math notranslate nohighlight">\(k\)</span> is
even, <span class="math notranslate nohighlight">\(\cos(\pi k)  = 1\)</span>, and the expression reduces to 0. Thus, the
Fourier series representing the square wave with period <span class="math notranslate nohighlight">\(L\)</span> looks like
this:
$<span class="math notranslate nohighlight">\(f(x) = \frac{4}{\pi}\sin(2 \pi x/ L)  + \frac{4}{3\pi}\sin(2 \pi 3 x/ L) +  \frac{4}{5\pi}\sin(2 \pi 5 x/ L) + ...\)</span>$
Notice how the coefficients decline for higher frequency terms. This
means that one can take a finite, often just a handful of
lowest-frequency terms and have a decent approximation of the function.
This is typical for most reasonable functions, as we will discuss below.</p>
<div class="section" id="complex-fourier-series">
<h3>complex Fourier series<a class="headerlink" href="#complex-fourier-series" title="Permalink to this headline">¶</a></h3>
<p>We have seen that periodic functions can be approximated by a sum of
sines and/or cosines of different frequencies, which is called the
Fourier series. Because both sines and cosines are needed to represent a
function that is not purely odd or even, a more compact complex
representation of the Fourier series is used:
$<span class="math notranslate nohighlight">\(f(x) = \sum_{n=-\infty}^\infty c_k e^{i2\pi x k/L}\)</span><span class="math notranslate nohighlight">\( Here \)</span>L<span class="math notranslate nohighlight">\( denotes
the length of the period of the function \)</span>f(x)<span class="math notranslate nohighlight">\(, and \)</span>c_n<span class="math notranslate nohighlight">\( are the
complex coefficients of the Fourier series, each corresponding to the
frequency \)</span>n/L$. They are found by the same integration as the ones for
sine and cosines series:</p>
<div class="math notranslate nohighlight">
\[c_k = \frac{1}{L}\int_{-L/2}^{L/2} f(x) e^{-i2\pi kx/L}dx; \; \; -\infty &lt; k &lt; \infty\]</div>
<p>The coefficient <span class="math notranslate nohighlight">\(c_0\)</span>, as can be seen from the integral, is the average
value of <span class="math notranslate nohighlight">\(f(x)\)</span> on the interval <span class="math notranslate nohighlight">\([-L/2,L/2]\)</span>.</p>
<p>In the complex Fourier series, positive and negative frequencies are
used in order to combine both sines and cosines into the same series, by
using the expressions
<span class="math notranslate nohighlight">\(e^{i2\pi x k/L} + e^{- i2\pi x k/L} =  2\cos(\pi x n/L)\)</span> and
<span class="math notranslate nohighlight">\(e^{i2\pi x n/L} - e^{- i2\pi x n/L} =  2i\sin(2\pi x n/L)\)</span>. Thus, the
complex coefficients <span class="math notranslate nohighlight">\(c_n\)</span> are related to the coefficients <span class="math notranslate nohighlight">\(a_k\)</span> and
<span class="math notranslate nohighlight">\(b_k\)</span> of the cosine and sine series as follows:
$<span class="math notranslate nohighlight">\(c_k = \frac{a_k -ib_k}{2}; \; c_{-k} = \frac{a_k + ib_k}{2}; \; k \geq 1\)</span><span class="math notranslate nohighlight">\(
Note that as long as \)</span>a_n<span class="math notranslate nohighlight">\( and \)</span>b_n<span class="math notranslate nohighlight">\( are real (which is the same as
saying the function \)</span>f(x)$ is real) the coefficients with opposite signs
will be complex conjugates of each other.</p>
</div>
<div class="section" id="sampling-theorem-and-aliasing">
<h3>Sampling theorem and aliasing<a class="headerlink" href="#sampling-theorem-and-aliasing" title="Permalink to this headline">¶</a></h3>
<p>By representing a periodic function <span class="math notranslate nohighlight">\(f(x)\)</span> in terms of the Fourier
series, we reduce its description to the values of the coefficients
<span class="math notranslate nohighlight">\(c_k\)</span>. We say that this set of coefficients is a representation in the
<em>frequency domain</em> as opposed to the time or space domain of the
original variable <span class="math notranslate nohighlight">\(x\)</span>. This is very useful for analyzing the types of
frequencies that a function contains.</p>
<p>To elaborate, <span class="math notranslate nohighlight">\(c_k\)</span> gives the weight of the sine or the cosine function
with frequency <span class="math notranslate nohighlight">\(k\)</span>, that is, one which has <span class="math notranslate nohighlight">\(k\)</span> repetitions within the
period <span class="math notranslate nohighlight">\(L\)</span>. Higher frequency terms are more wiggly, and are needed to
represent functions with high slopes. Lower frequency terms represent
the larger, slower varying shape of the function. For any reasonable
function, the higher frequency terms will generally have smaller
coefficients than lower-frequency terms, and for really high frequencies
will be very small. This enables one simple use of the Fourier series: a
periodic function can be approximated by a few lower-frequency terms, so
it can be represented by a few numbers. This has great applications in
image and sound compression.</p>
<p>The highest frequency possibly in a sample of <span class="math notranslate nohighlight">\(N\)</span> data points is called
the <em>Nyquist critical frequency</em> <span class="math notranslate nohighlight">\(f_c\)</span>. It depends on the sampling
interval <span class="math notranslate nohighlight">\(\Delta\)</span> like this: <span class="math notranslate nohighlight">\(f_c = 1/2\Delta\)</span>. The intuition behind
this is that in order to detect a frequency <span class="math notranslate nohighlight">\(f\)</span>, one needs to make at
least two measurements during one period <span class="math notranslate nohighlight">\(1/f_c\)</span>. (Convince yourself of
this by drawing a sine wave and sampling it two or fewer times per
period.) Since each measurement takes <span class="math notranslate nohighlight">\(\Delta\)</span> units, the highest
frequency we can sample is <span class="math notranslate nohighlight">\(1/2\Delta\)</span>. This leads to a remarkable
result, called the Sampling Theorem:</p>
<p><strong>Theorem:</strong> If a function <span class="math notranslate nohighlight">\(h(x)\)</span> contains no higher frequencies than
some <span class="math notranslate nohighlight">\(f_c\)</span>, more precisely its Fourier transform <span class="math notranslate nohighlight">\(\hat h(f) = 0\)</span> for any
<span class="math notranslate nohighlight">\(f&gt;f_c\)</span>, then this function can be completely represented by a sample
with the interval <span class="math notranslate nohighlight">\(\Delta\)</span> such that <span class="math notranslate nohighlight">\(\Delta &lt; 1/2f_c\)</span>.</p>
<p>Practically, this means that any function that does not change too
abruptly (which requires higher frequency terms) can be represented by a
discrete set of low-frequency terms. However, in practice there is
always noise or abrupt changes, so one cannot have what is known a
<em>bandwidth limit</em> (meaning the band of frequencies contributing to the
function is limited). Then, when we try to represent a function with a
discrete set of points that we Fourier-transform, when we perform the
inverse FT, we get error due to lack of the high-frequency terms. This
is called <em>aliasing</em> error.</p>
</div>
<div class="section" id="discrete-fourier-transform">
<h3>Discrete Fourier Transform<a class="headerlink" href="#discrete-fourier-transform" title="Permalink to this headline">¶</a></h3>
<p>Now let us consider a series of data points, instead of idealized
functions, since in reality the data are never described by perfect
continuous functions. Let us suppose that they come from measuring a
certain function <span class="math notranslate nohighlight">\(f(x)\)</span> over a range of length <span class="math notranslate nohighlight">\(L\)</span> at regular intervals.
This is called <em>sampling</em> of the function and the sampling interval (in
units of <span class="math notranslate nohighlight">\(x\)</span>) between the sample points is called <span class="math notranslate nohighlight">\(\Delta = L/N\)</span>, where
<span class="math notranslate nohighlight">\(N\)</span> is the number of sample points. As a result, we get a sequence of
<span class="math notranslate nohighlight">\(N\)</span> measurements <span class="math notranslate nohighlight">\(\{x_i\}\)</span>. In order to decompose the sampled inputs
into their frequency components, we need to find the coefficients of the
Fourier series. Let us use the notation <span class="math notranslate nohighlight">\(\{X_k\}\)</span> for the Fourier
coefficients, and define the following the <em>Discrete Fourier Transform</em>:
$<span class="math notranslate nohighlight">\(X_{k} = \sum_{n=0}^{N-1} x_{n} e^{-i 2\pi kn /N}
 \label{eq:dft}\)</span><span class="math notranslate nohighlight">\( It is called the Discrete Fourier Transform because it
is based on the finite data set, and thus computation of coefficients
requires summation instead of integration. Let us consider what
frequency each coefficient \)</span>X_k<span class="math notranslate nohighlight">\( corresponds to. When \)</span>k=0<span class="math notranslate nohighlight">\(, \)</span>e^0=1<span class="math notranslate nohighlight">\( and
we just have the sum of all the sample points. This is called the zero
frequency term, or sometimes the DC (direct current) term by electrical
engineers. The other terms have frequencies given by \)</span>k/N<span class="math notranslate nohighlight">\(, all the way
up to \)</span>(N-1)/N<span class="math notranslate nohighlight">\(. Note here that we assume for convenience that the
interval \)</span>\Delta<span class="math notranslate nohighlight">\( is 1, so the frequency corresponds to the fraction of
points in the cycle (e.g. \)</span>k/N<span class="math notranslate nohighlight">\(). The frequency ranges from the lowest
of \)</span>1/N<span class="math notranslate nohighlight">\( to the highest of \)</span>(N-1)/N<span class="math notranslate nohighlight">\(. However, the highest frequency is
actually equivalent to \)</span>-1/N<span class="math notranslate nohighlight">\(, because going around the \)</span>(N-1)/N<span class="math notranslate nohighlight">\(
fraction of a circle in one direction is the same as going \)</span>1/N$
fraction in the opposite direction.</p>
<p>Thus, the first half of the coefficients correspond to positive
frequencies in increasing order, until the frequency <span class="math notranslate nohighlight">\(1/2\)</span> is reached,
and then the coefficients correspond to negative frequencies in
descending order of the absolute value. In fact, if the input points are
real, the coefficients of positive and negative frequencies are
symmetric, and so for the MATLAB indexing above, we have:
<span class="math notranslate nohighlight">\(C(k+1) = C(N-k+1)\)</span> (for <span class="math notranslate nohighlight">\(k&gt;0\)</span>). This is because the complex terms have
to add up to real numbers, so this ensures that terms with opposite
frequencies are complex conjugates (convince yourself of this fact).</p>
</div>
</div>
<div class="section" id="computational-fast-fourier-transform">
<h2>Computational: Fast Fourier Transform<a class="headerlink" href="#computational-fast-fourier-transform" title="Permalink to this headline">¶</a></h2>
<p>Now let us get down to the business of computing the Fourier
decomposition of an input of <span class="math notranslate nohighlight">\(N\)</span> data points. In equation [eq:dft] in
the discrete Fourier transform section, we found an analytic formula for
finding the coefficients of a complex Fourier series by summation of <span class="math notranslate nohighlight">\(N\)</span>
components. In order to obtain all <span class="math notranslate nohighlight">\(N\)</span> Fourier coefficients, we would
need to perform approximately <span class="math notranslate nohighlight">\(N^2\)</span> operations (<span class="math notranslate nohighlight">\(N\)</span> multiplications plus
<span class="math notranslate nohighlight">\(N-1\)</span> additions for each of the <span class="math notranslate nohighlight">\(N\)</span> coefficients). This means that as
the number of inputs grows, the computational cost of performing the
Discrete Fourier Transform grows quadratically. This is a major problem
because Discrete Fourier Transforms are so ubiquitous - they are at the
heart of graphics engines, audio and image analysis, and many other
computationally intensive applications. In this section we will describe
a truly transformational algorithm which dramatically reduces the
computational cost of a DFT, descriptively called the Fast Fourier
Transform (FFT). Specifically, we will describe the classic Cooley-Tukey
algorithm \cite{}, which was the first type of FFT; subsequently other
variations were developed, which have some advantages, but the original
FFT is so fundamental to modern computing that I will present it in this
section.</p>
<div class="section" id="splitting-the-data-into-even-and-odd-inputs">
<h3>splitting the data into even and odd inputs<a class="headerlink" href="#splitting-the-data-into-even-and-odd-inputs" title="Permalink to this headline">¶</a></h3>
<p>Let the set of inputs for the Discrete Fourier Transform consist of <span class="math notranslate nohighlight">\(N\)</span>
numbers, <span class="math notranslate nohighlight">\(\{x_n\}\)</span>. This number <span class="math notranslate nohighlight">\(N\)</span> could be large, and practicing
computational scientists have thought about a way of simplifying the
calculation. It turns out that there is a beautiful symmetry in the
Fourier calculation that enables the calculation of the Fourier
coefficients of <span class="math notranslate nohighlight">\(N\)</span> data points in terms of the Fourier coefficients of
two halves of the data set: the even and the odd numbered inputs. First,
let us write down the expression in equation [eq:dft] in terms of sums
of the <span class="math notranslate nohighlight">\(N/2\)</span> even and the <span class="math notranslate nohighlight">\(N/2\)</span> odd inputs, as follows:
$<span class="math notranslate nohighlight">\(X_{k} = \sum_{n=0}^{N-1} x_{n} e^{-i 2\pi kn /N} = \sum_{m=0}^{N/2-1} x_{2m} e^{-i2\pi (2m)k/N} + \sum_{m=0}^{N/2-1} x_{2m+1} e^{-i2\pi (2m+1)k/N}\)</span><span class="math notranslate nohighlight">\(
The two sums look very similar to the sum that produces the Fourier
coefficients for the \)</span>N<span class="math notranslate nohighlight">\( inputs. In fact, the first sum, is identical to
the DFT of the even-numbered inputs, which we will denote as
\)</span>X_{k}^{(e)}<span class="math notranslate nohighlight">\(. The second sum can be transformed by taking the factor
\)</span>e^{-i2\pi k/N}<span class="math notranslate nohighlight">\( out of the sum into the sum for the DFT of the
odd-numbered inputs , which we denote \)</span>X_k^{(o)}<span class="math notranslate nohighlight">\(. Conventionally in
Fourier literature, the factor \)</span>e^{-i2\pi k/N}<span class="math notranslate nohighlight">\(, which is the \)</span>N<span class="math notranslate nohighlight">\(th root
of unity raised to the \)</span>k<span class="math notranslate nohighlight">\(th power, is called the *twiddle* factor, and
is notated \)</span>w^k<span class="math notranslate nohighlight">\( (for \)</span>N<span class="math notranslate nohighlight">\( inputs). Therefore, we have the following
expression: \)</span><span class="math notranslate nohighlight">\(X_k = X_{k}^{(e)} + w^k X_k^{(o)}\)</span><span class="math notranslate nohighlight">\( Note that this formula
works for \)</span>0\leq k \leq N/2-1<span class="math notranslate nohighlight">\(, since the DFTs of halves of the data set
have only half of the outputs (\)</span>N/2<span class="math notranslate nohighlight">\(). However, due to its periodicity,
the DFT repeats itself for coefficients that go beyond the size of the
inputs; for a DFT of size \)</span>N<span class="math notranslate nohighlight">\(, \)</span>X_{k} = X_{k-N}<span class="math notranslate nohighlight">\(. Therefore, we can
compute the other half of the Fourier coefficients of the original data
set (\)</span>0 \leq k \leq N/2-1<span class="math notranslate nohighlight">\() to obtain the same formula:
\)</span><span class="math notranslate nohighlight">\(X_{k} = X_{k}^{(e)} + w^{k} X_{k}^{(o)}
 \label{DL_lemma}\)</span><span class="math notranslate nohighlight">\( This result, known as the *Danielson-Lanczos lemma*,
allows the calculation of a DFT with \)</span>N<span class="math notranslate nohighlight">\( inputs, in terms of the
coefficients of two DFTs with \)</span>N/2<span class="math notranslate nohighlight">\( inputs. It is clear that even
applying this splitting once leads to computational advantage, since as
we noted above, DFT requires on the order of \)</span>N^2<span class="math notranslate nohighlight">\( arithmetic
operations. Thus, performing DFTs on half of the number of inputs will
reduce the number of calculations by a factor of 4, and since it is
performed for each half of the data, this results in approximately
two-fold reduction in operations, as it requires only on the order of
\)</span>N$ additional operations to reassemble the full DFT.</p>
</div>
<div class="section" id="recursive-splitting-and-reassembly">
<h3>recursive splitting and reassembly<a class="headerlink" href="#recursive-splitting-and-reassembly" title="Permalink to this headline">¶</a></h3>
<p>If splitting the problem in half once reduces the computational cost,
why not do it again? and again? This was the idea that Cooley and Tukey
came up with in 1965. For example, if the number of inputs is divisible
by 4, one can split the data sets into even- and odd-numbered halves,
and then split each of those into even and odd-numbered halves, and
perform DFT on the quarter-data sets separately. The resulting four sets
of Fourier coefficients will be labeled <span class="math notranslate nohighlight">\(\{X^{(ee)}\}\)</span>, <span class="math notranslate nohighlight">\(\{X^{(eo)}\}\)</span>,
<span class="math notranslate nohighlight">\(\{X^{(oe)}\}\)</span>, and <span class="math notranslate nohighlight">\(\{X^{(oo)}\}\)</span> (e.g. the second one represents the
quarter of data set that had even indices in the original set, and odd
indices in the even half, corresponding to indices 2,6,10, etc.), and
they can be recombined in order to compute the Fourier coefficients of
the entire set. Using the above formula, we can find the the expression
for reassembling the four quarter-size DFTs to compute the DFT. The
twiddle factor for quarter-size data sets is
<span class="math notranslate nohighlight">\(e^{-i2\pi k/(N/2)} =e^{-i2\pi 2k/N}  = w^{2k}\)</span>. Therefore, the formula
for the DFT, for indices <span class="math notranslate nohighlight">\(0 \leq k \leq N-1\)</span> is:
$<span class="math notranslate nohighlight">\(X_k =  X^{(ee)} + w^{2k}X^{(eo)}  + w^k X^{(oe)} + w^{3k} X^{(oo)}\)</span>$</p>
<p>We can continue further dividing the data into halves and reassembling
the resulting DFT coefficients, as long as the number of data points in
the subsets is divisible by two. In order to achieve maximal
decomposition, let us assume that the number of inputs is a power of 2
(<span class="math notranslate nohighlight">\(N=2^M\)</span>). Then after <span class="math notranslate nohighlight">\(M\)</span> such divisions into even and odd subsets, the
data are subdivided into <span class="math notranslate nohighlight">\(N\)</span> subsets of single values. The DFT of a
single data point, by the formula above in equation [eq:dft], is just
the data point. Therefore, for any data point with a given pattern of
even and odd divisions, e.g. <span class="math notranslate nohighlight">\(ooeeo...\)</span>, there is a corresponding
singlet DFT with index <span class="math notranslate nohighlight">\(n\)</span>: $<span class="math notranslate nohighlight">\(x_n  =  X^{(ooeeo...)}\)</span><span class="math notranslate nohighlight">\( The question is,
how does the index \)</span>n<span class="math notranslate nohighlight">\( of the data point correspond to the string of
even and odd divisions in the DFT? The answer turns out to be simple and
elegant in binary representation of indices. Consider, for example, a
data set of four input values, indexed \)</span>{x_0,x_1,x_2, x_3}<span class="math notranslate nohighlight">\(. The first
division splits them into \)</span>{x_0,x_2}<span class="math notranslate nohighlight">\( and \)</span>{x_1,x_3}<span class="math notranslate nohighlight">\(, and the
second subdivides them into singleton sets:
\)</span>{x_0},{x_2},{x_1},{x_3}<span class="math notranslate nohighlight">\(. The rearrangement of indices due to
divisions into evens and odds is captured by *bit reversal* of the
binary indices. In binary, we can write \)</span>0=00; 1=01; 2=10; 3=11<span class="math notranslate nohighlight">\(.
Reversing the bits, that is re-writing the binary numbers from right to
left, yields: \)</span>00=0, 10=2, 01=1; 11=3$, which is exactly the order we
produced by two splittings. Therefore, we can find the DFTs of each of
the resulting singleton sets by reordering the input values by
bit-reversal and then recombining them using the Danielson-Lanczos
formula above.</p>
<p><strong>Example.</strong> Let us calculate the DFT for the data set
<span class="math notranslate nohighlight">\(\{x_0, x_1, x_2, x_3\} = \{2,  -1, 2, -1 \}\)</span>. As we saw above, we split
the four inputs into halves twice until we are left with singleton sets,
which are then arranges as follows:
<span class="math notranslate nohighlight">\( \{x_0, x_1, x_2, x_3 \}  = \{2,  2 -1, -1 \}\)</span>. Then we recombine the
value with appropriate twiddle factors to calculate the DFT. First,
Calculate the twiddle factors for DFT with <span class="math notranslate nohighlight">\(N=2\)</span>:
$<span class="math notranslate nohighlight">\(w_0 = 1; \;  w_1 = e^{-i\pi} = -1\)</span><span class="math notranslate nohighlight">\( \)</span><span class="math notranslate nohighlight">\(X_0^{(e)} = x_0 + x_2 = 4\)</span><span class="math notranslate nohighlight">\(
\)</span><span class="math notranslate nohighlight">\(X_1^{(e)} = x_0 + w^1x_2 = 0\)</span><span class="math notranslate nohighlight">\( \)</span><span class="math notranslate nohighlight">\(X_0^{(o)} =  x_1 + x_3 =  - 2\)</span><span class="math notranslate nohighlight">\(
\)</span><span class="math notranslate nohighlight">\(X_1^{(o)} =  x_1 + w^1 x_3 =  0\)</span><span class="math notranslate nohighlight">\( Calculate the twiddle factors for
\)</span>N=4<span class="math notranslate nohighlight">\(:
\)</span><span class="math notranslate nohighlight">\(w_0 = 1; \;  w_1 = e^{-i\pi/2} = -i ; \; w_2 = e^{-i\pi } = -1 ;\;  w_3 = e^{-i3\pi/2} = i\)</span><span class="math notranslate nohighlight">\(
\)</span><span class="math notranslate nohighlight">\(X_0 =  X_0^{(e)}  + X_0^{(o)} = 2\)</span><span class="math notranslate nohighlight">\(
\)</span><span class="math notranslate nohighlight">\(X_1 =  X_1^{(e)}  + w^1 X_1^{(o)}  = 0\)</span><span class="math notranslate nohighlight">\(
\)</span><span class="math notranslate nohighlight">\(X_2 =  X_0^{(e)}  + w^2 X_1^{(o)}  = 6\)</span><span class="math notranslate nohighlight">\(
\)</span><span class="math notranslate nohighlight">\(X_3 =  X_1^{(e)}  + w^3 X_1^{(o)} =  0\)</span>$ Each DFT coefficient contains
information about the periodicity of the data set: the zeroth one is the
sum (average signal); the first one measures the strength of the period
one component (in this case, none), the second one is the strength of
the period two component (in this case, the only frequency present), and
the third one mirrors the period one (since there cannot be a period
three signal measured in four points.)</p>
<p>This calculation a small data set how the FFT algorithm reduce the
calculation of the DFT coefficients to reassembling the values of the
inputs <span class="math notranslate nohighlight">\(x_k\)</span> with the bit-reversed indices with appropriate twiddle
factors. This is illustrated in the following figure
[fig:fft_butterfly], known as the “FFT butterfly” for its visual
appearance. The figure demonstrates how the original data points on the
left, if arranged in the bit-reversed order are scrambled up by the
even/odd divisions, and how they end up in the normal order on the right
hand side.</p>
<p>The result of the FFT calculation is exactly the same as the direct DFT,
but the FFT takes fewer arithmetic operations to perform. As mentioned
above, computing the DFT directly requires <span class="math notranslate nohighlight">\(O(N^2)\)</span> operations (the
notation means a scalar multiple of <span class="math notranslate nohighlight">\(N^2\)</span>). The FFT starts by
rearranging the data using bit-reversal (which takes only a small number
of calculations). The key to efficiency is recursive reassembly of the
DFT, which happens <span class="math notranslate nohighlight">\(\log_2 (N)\)</span> times, one for each split (assuming that
<span class="math notranslate nohighlight">\(N\)</span> is a power of two, which allows for a clean division into
singletons.) This calculation, as shown in equation [DL_lemma],
requires only two operations (an addition and a multiplication by the
precomputed twiddle factor) for each of the <span class="math notranslate nohighlight">\(N\)</span> DFT coefficients.
Therefore, the total number of operations for FFT is <span class="math notranslate nohighlight">\(O(N \log_2 (N) )\)</span>
instead of <span class="math notranslate nohighlight">\(O(N^2)\)</span> for DFT. This results is a huge gain in efficiency
for large data sets, for example, for a million data points
<span class="math notranslate nohighlight">\(\log_2(10^6) \approx 20\)</span>, the number of operations is reduced by a
factor of 50,000.</p>
<p><img alt="FFT butterfly for 8 inputpoints[]{data-label=&quot;fig:fft_butterfly&quot;}" src="_images/fft_butterfly.png" /></p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    

</div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Dmitry Kondrashov<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>